*winds6-s
* 9.9.2009- fixed SCSI EOF bug; CLRE2
*
CORBU1 MOV  @H0092,@CHRCNT    CHARACTER COUNT IS LOGICAL RECORD LENGTH
       MOVB @CBH00,@CHRCNH    ZERO OUT THE MSB
CDIRP2 BL   @SETAXB           SET RAMBUF POINTER AND R1
       MOV  @RECNUM,R10       TEST IF RECORD 0
       JNE  DRED1             BRANCH IF NOT RECORD 0
* TO BE HERE IT IS RECORD 0 SO TEST IF MAIN DIRECTORY OR A SUBDIRECTORY
* R8 POINTS TO DCB BUFFER
       CB   R6,@CBH3B
       JEQ  CDIR00
       MOV  R8,R0
       MOV  R0,R7
       MOV  @FNVSOF(R3),R1    TEST IF MAIN OR SUB DIR
       JNE  DONE4             IS A SUB DIR
* NOW FIRST PUT IN VOLUME NAME OF WINCHESTER
       BLWP @STTOBF           BRANCH TO MOVE NAME TO BUFFER
* NOW MOVE A FLOATING ZERO TO THE BUFFER TO INDICATE THE MAIN DIRECTORY
       CLR  R0
       BLWP @CIF              FLOATING TO BUFFER
* NOW GET # OF AU'S ON DISK
CDIR00 CLR  R7
       MOV  @TOTAU(R8),R10
       MOV  R10,@COMBUF       FOR USE BY DIR
*
* NOW GET TOTAL NUMBER OF AVAILABLE
* USE R10 FOR NUMBER OF SECTORS TO COUNT COUNTER
* USE R7 FOR AVAILABLE COUNTER
*
       CLR  @AUNUM
NVBUF  INC  @AUNUM
       BLWP @RSECDR              GET THE SECTOR
       JEQ  BADDIO
       LI   R0,128
       LI   R6,GTSBUF
DONE1  BL   @NXTWD
*
NXTWD  AI   R7,16             ASSUME ALL 16 AVAILABLE
       MOV  *R6+,R5           TEST IF ALL USED
       JEQ  UPDATE
       CI   R5,>FFFF
       JNE  NBIT1             BRANCH IF NOT ALL USED
       AI   R7,-16            ALL USED
UPDATE AI   R10,-16
       JEQ  DONE1Y            BRANCH IF COMPLETE
       JNC  DONE1Y            IN CASE WE HAVE TO STOP IT HERE
       DEC  R0                WORD COUNTER
       JNE  NXTWD             BRANCH IF NOT ZERO TO NEXT WORD
       JMP  NVBUF
*
NBIT   JEQ  UPDATE
NBIT1  SLA  R5,1
       JNC  NBIT
       DEC  R7
       JMP  NBIT1
*
DONE1Y CB   @OPCODE,@CBH3B
       JNE  DONE1A
       B    @CDIR2            PUT IN THE HEADER IN THE CALL DIR() FUNCTION
*
DONE1A MOV  @COMBUF,R0
       BLWP @CIFAU
       MOV  R7,R0
       MOV  R8,R7
DONE3  BLWP @CIFAU
       MOV  R7,R10
       AI   R10,DATCRD
       BL   @DATNUM           DATE AND TIME OF CREATION
* NOW FOR NUMBER OF FILES IN THIS DIRECTORY
*      MOV  @NUMFIL(R7),R0
*      SRL  R0,8
*      BLWP @CIF
* NOW FOR NUMBER OF SUBDIRECTORIES
*      MOVB @NUMDIR(R7),R0
*      SRL  R0,8
*      BLWP @CIF
* NOW FOR THE NUMBER OF SECTORS PER AU IN MAIN DIRECTORY ONLY
*      ABS  @FNVSOF(R3)
*      JNE  NRECD
*      MOV  @WINTYP(R7),R0
*      SRL  R0,12
*      INC  R0
*      BLWP @CIF
* NOW COMPLETE, SO RETURN TO OS BUT FIRST INCREMENT THE RECORD NUMBER FOR NEXT D
NRECD  INC  @RECNUM
ERRT1  B    @FINISH
*
* NOW RETURN NORMAL DIR DATA (POINTER IN R1 TO BUFFER)
DONE4  MOV  R7,R0
       CB   @OPCODE,@CBH3B
       JNE  DONE4B
       LI   R0,COMBUF
       MOV  @H0006,*R0+
       CLR  *R0+
       CLR  *R0+
       MOV  @H0002,*R0
       B    @DRED7A
       PAGE
* TO BE HERE, TEST IF FILE OR DIRECTORY READ
* ALWAYS READ FILES FIRST THEN DIRECTORIES
DRED1  MOVB @NUMFIL(R8),R7
       SRL  R7,8
       C    R7,R10
       JHE  DRED4             READ A FILE
* NOW TEST IF R10 IS <= 241  (127+114)
       CI   R10,241
       JLE  DRED5
* NOW FOR TRYING TO READ PAST END OF FILE
EOFSDR CB   @OPCODE,@CBH3B
       JEQ  NODIRA
       LI   R0,>A000
BADDIO B    @BADOPC           SINCE IN INPUT MODE, JUST FINISH UP
*
* NOW GET THE DIRECTORY, BUT FIRST TEST IF A DIRECTORY EXISTS HERE
DRED5  S    R7,R10
       MOV  @NUMFIL(R8),R7
       SZCB R7,R7             MASK OFF FILE PART
       C    R7,R10            IF R7 >= TO R10 THEN OKAY TO GIVE DIRECTORY
       JL   NODIR             BRANCH IF NO DIR EXISTS
* OTHERWISE GET IT IN BUFFER SIBLIN AND USE IT
       SLA  R10,1             GET WORD BOUNDARY FOR NO.
       A    R8,R10
       MOV  @DIRPTS-2(R10),@AUNUM
       BLWP @RSECTR
       JEQ  BADDIO
       LI   R7,GTSBUF
       JMP  DONE4
*
DONE4B BLWP @STTOBF
* NOW RETURN TYPE 6 OR DIRECTORY
       LI   R0,6
       BLWP @CIF              CONVERT TO FLOATING POINT
* NOW FOR NUMBER OF AU'S USED BY DIR (2)
       LI   R0,2
       BLWP @CIF
* NOW A ZERO FOR NUMBER OF AU'S AVAILABLE
       CLR  R0
       JMP  DONE3
       PAGE
* NOW RETURN NON EXISTANT DIR OR FILE
NODIR  CB   @OPCODE,@CBH3B
       JNE  N2
NODIRA SZCB @CHAT,@CHAT
       JMP  ERRT1
*
N2     LI   R0,BLANK      POINT TO BLANK BYTE
       BLWP @STTOBF
* NOW RETURN 15 ZERO'S
       LI   R10,15
N      CLR  R0
       BLWP @CIF
       DEC  R10
       JNE  N
       JMP  NRECD
       PAGE
* NOW FOR READING A FILE, SO TEST IF FIRST IF IN RANGE
DRED4
* NOW GET FCB
       SLA  R10,1             WORD PNTR
       A    R9,R10
       MOV  @-2(R10),@AUNUM
       BLWP @RSECTR
       JEQ  BADDIO
* NOW GET ALL FILE PARMS
* WE KNOW THAT R1 POINTS TO THE FCB
* FIRST MOVE NAME
       LI   R2,GTSBUF
*      MOV  R2,R0
*      BLWP @STTOBF
* NOW GET FILE TYPE             (NEGATIVE IF PROTECTED)
* 1=DISPLAY/FIXED DATA FILE
* 2=DISPLAY/VARIABLE DATA FILE
* 3=INTERNAL/FIXED DATA FILE
* 4=INTERNAL/VARIABLE DATA FILE
* 5=PROGRAM FILE
       MOVB @FSTATF(R2),R10           GET STATUS FLAGS
* FLAGS ARE 2,4-6 NOT USED (O is LSB, 7 is MSB)
* 0-FILE TYPE 0-DATA   , 1-PROGRAM
* 1-DATA TYPE 0-DISPLAY, 1-INTERNAL
* 3-PROTECTED 0-UNPROT , 1-PROTECTED
* MSB-RECORD TYPE 0-FIXED, 1-VARIABLE
       LI   R0,7
       CLR  R7
       CLR  @CIFLN9
       COC  @H2000,R10
       JEQ  PFILE1
       MOV  @NIBLES(R2),R6
       SRL  R6,12
       MOV  @LEV2RC(R2),R7    LENGTH OF PROGRAM file in sectors
       MOVB R7,R6
       SWPB R6                we have 28 bits now..plenty
       MOVB @EOFOST(R2),R7    # of bytes used in last sector (0 if all)
       JEQ  INTERA
       DEC  R7
       JOC  INTERA
       DEC  R6
INTERA SWPB R7
       MOV  R6,@CIFLN9
       DECT R0
       COC  @H0100,R10        TEST FOR PROGRAM FILE
       JEQ  PFILE1            BRANCH IF PROGRAM FILE
       CLR  @CIFLN9
       MOV  @EOFOST(R2),R7    LOGICAL RECORD LENGTH FOR LATER USE
       SZCB R7,R7
       MOV  R7,R7
       JNE  INTERB
       MOV  @XRECLN(R2),R7    GET EXTENDED RECORD LENGTH
INTERB DEC  R0
* NOW TEST IF DISPLAY OR INTERNAL
       COC  @H0200,R10
       JEQ  INTER             BRANCH IF INTERNAL
       DECT R0                ELSE IS DISPLAY
* NOW TEST IF FIXED OR VARIABLE
INTER  MOV  R10,R10           TEST MSB
       JLT  VARI              BRANCH IF VARIABLE
       DEC  R0
VARI
PFILE1
* NOW TEST IF PROTECTED OR NOT
       COC  @H0800,R10
       JNE  NOTPRR            BRANCH IF NOT PROTECTED
       NEG  R0                ELSE NEGATE R0
NOTPRR MOV  R0,@COMBUF        STORE FOR LATER USE TYPE
       MOV  R7,@COMBUF+2      RECORD LENGTH
       LI   R6,1              ONE SECTOR IN CASE OF FLOPPY
* NOW FOR TOTAL # OF SECTOR'S ALLOCATED TO THE FILE
       MOV  @VOLUME,R6
       SLA  R6,3
       MOV  @CYLPLT-8+6(R6),R6
       SRL  R6,12
       INC  R6
       MOV  R6,R7
NXTFCB MOV  @PTRNXT(R2),@AUNUM
       JEQ  NOFCB
       A    R7,R6
       BLWP @RSECTR
       JNE  NXTFCB
DRED10 B    @BADOPC
*
CIFLN9 DATA 0                 high word of pgm length
*
NOFCB
DRED9  MOV  @PTRPRE(R2),@AUNUM
       JEQ  DRED8
       BLWP @RSECTR
       JNE  DRED9             ERROR?
       JMP  DRED10            YES, AN ERROR
*
DRED8  MOV  R6,R0
       CLR  R6
       MOV  @NIBLES(R2),R6
       SRL  R6,12
       MOV  R6,@COMBUF+4
       A    @LEV2RC(R2),R0
       JNC  DRED7
       INC  @COMBUF+4
DRED7  MOV  R0,@COMBUF+6      SAVE THE ENTIRE
       CB   @OPCODE,@CBH3B
       JNE  NOTCD
       MOV  R2,R7             PUT POINTER TO NAME IN R7 FOR NEXT PAGE
DRED7A B    @CDIR3
*
NOTCD  LI   R0,GTSBUF
       BLWP @STTOBF
       MOV  @COMBUF,R0
       BLWP @CIF
       BLWP @CIFLNG           NOW THE # OF SECTORS ALLOCATED TO THE FILE
       MOV  @COMBUF+2,R0      yalfu..pgm image bytes need 24 bits at least
       BLWP @CIFLEN           NOW THE RECORD LENGTH (OR # OF BYTES IF PGM)
* NOW GET CREATION DATE AND TIME IN COMBUF+4 AND COMBUF+6
       MOV  R2,R7
*      AI   R7,DATCRF+2
       AI   R7,DATCRF
       MOV  R7,R10
       BL   @DATNUM
       AI   R7,4
       MOV  R7,R10
       BL   @DATNUM
       B    @NRECD
*
BADOP5 SOCB @CBHA0,@PABERR
       B    @CLRE1
*
CBHA0  DATA >A000
*
       DATA >1234
*
READ
WRITE
*  FIRST FIND IF FILE OPEN
       CI   R2,WBUFEN
       JNE  ISOP              BRANCH IF ALREADY OPEN
* NOW TEST IF DISKETTE OR WINCHESTER
CLRE2  LI   R0,>E000
       CB   @PATHNM,@CHARW    IS IT WINCHESTER?
       JEQ  NOTOPN            YES, SO BOMB, BUT PASS ON CALL OTHERWISE
       CB   @PATHNM,@TEXSCS   9.9.2009 Is it SCSI?
       JEQ  NOTOPN            9.9.209 Yes, BOMB-fixes SCSI EOF lockup
       B    @FLPRTN           BRANCH IF FLOPPY
*
NOTOPN B    @BADOP
*
*  R3 POINTS TO F N BUF LOCATION
*
ISOP   MOV  @VOLUME,R2
       SLA  R2,3
       CLR  @PASRW            ASSUME A READ
       CB   @CBH03,R6
       JNE  RE1               IT IS A READ
       SETO @PASRW
*  GET DATE AND TIME FOR LAST UPDATE
       MOV  @TIMCM1,@LSTUP1(R3)
       MOV  @TIMCM2,@LSTUP2(R3)
*
RE1    ABS  @DIRIO            FILE OR DIRECTORY?
       JEQ  FII000            FILE
       B    @CORBU1           ONLY ACCEPT A READ
*
*  TEST IF FIXED OR VARIABLE
FII000 CLR  @DIGFLG
       COC  @H0010,R6
       JEQ  VREWRT            BRANCH IF VARIABLE
       B    @FREWRT           FIXED
*
*   TO BE HERE, THERE ARE 2 POSSIBLE FORMATS FOR I/O
*    IF LOGICAL RECORD LENGTH IS 254 OR LESS THEN THE OLD TI
*       FORMAT
*    IF LOGICAL RECORD LENGTH IS 255 OR GREATER THEN
*       THE FORMAT USED IS A 2 BYTE HEADER WHICH IS
*       THE LENGTH FOLLOWED BY THE RECORD WITH NO
*       FILLERS IN BETWEEN
*
VREWRT CB   R6,@CBH02    READ?
       JNE  WRTV1        WRITE
* READ SO ZERO OUT THE NUMBER OF CHARACTERS READ SO FAR
       CLR  @CHRCNT
       MOVB @CBH00,@CHRCNH
* READ SO TEST IF AT END OF FILE
       CB   @FNLOFM(R3),@FNVSOF(R3)    MSB
       JH   BADOP5
       JL   VARI00
       C    @FNLOF2(R3),@FNVNAU(R3)    LSW
       JH   BADOP5
       JL   VARI00
       CB   @FNLROF(R3),@FNVROF(R3)    SECTOR OFFSET
       JHE  BADOP5
VARI00 CLR  R4                RECORD LENGTH
       MOVB @FNLROF(R3),R10   DO WE NEED TO GET THE NEXT SECTOR
       JEQ  NSECTR            YES
       JMP  NSEC02
*
THS003 MOV  R4,R4             HAVE WE READ THE REC LENGTH ALREADY?
       JNE  THS007            YES
       MOV  @XRECLN(R9),R11   IS IT OLD OR NEW FORMAT
       JNE  THS004            NEW FORMAT
       MOVB *R10+,R4          GET CHARCNT OF THIS RECORD
       CB   R4,@CBHFF         AT END?
       JNE  THS006            NOT YET
       MOVB @CBH00,@FNLROF(R3)
       CLR  R4                we don't have a record length yet
NSECTR BLWP @GETAUU
       MOV  R0,R0             ERROR?
       JNE  BADD02
       INC  @FNLOF2(R3)
       JNC  NSEC00
       AB   @CBH01,@FNLOFM(R3) yalfu
NSEC00 MOV  R8,@RAMBUF
       BLWP @RSECTR
       JEQ  BADD02
       BL   @PUTDSL
       CLR  R10
       MOVB R10,@FNLROF(R3)
NSEC02 SRL  R10,8
       A    R8,R10
       CLR  R2
       MOV  @DIGFLG,R0        IS THIS THE SECOND BYTE OF THE REC LEN?
       JNE  THS004            YES, IT IS
       JMP  THS003
*
BADD02 B    @BADD00
*
THS004 INV  @DIGFLG           IS <>0 IF FIRST DIGIT
       JEQ  THS005            GO GET MSB OF LENGTH
*
       MOVB *R10+,R4          GET MSB
       SWPB R4
       AB   @CBH01,@FNLROF(R3)  UP SECTOR POINTER
       JEQ  NSECTR            GET LSB
*
THS005 MOVB *R10+,R4          GET THE LSB
THS006 SWPB R4
       AB   @CBH01,@FNLROF(R3)
       MOV  R4,@CHRCNT
       JEQ  SYRT04            LENGTH IS ZERO SO RETURN
*
*  NOW TO MOVE R4 BYTES
*
       MOVB @FNLROF(R3),R10
       JEQ  NSECTR            HAVE TO GET THE NEXT SECTOR
       SRL  R10,8
       MOV  R10,R2
       A    R8,R10            NOW R10 POINTS TO WHERE DATA BEGINS
THS007 NEG  R2
       AI   R2,256            NOW R2 HAS # OF AVAILABLE BYTES IN SECTOR
       C    R2,R4             IS THERE ENOUGH IN THE SECTOR FOR R4?
       JL   THS008
       MOV  R4,R2
THS008 BL   @IOTOSB
       SWPB R2
       AB   R2,@FNLROF(R3)    UPDATE PTR WITHIN SECTOR AND # OF
       SWPB R2                  CHARS LEFT IN RECORD TO IO
       S    R2,R4
       JNE  NSECTR
SYRT04 B    @FINISH
       PAGE
WRTV1  CLR  @DATMFG           WE ARE GOING TO WRITE RECORD LENGTH FIRST
       MOV  @XRECLN(R9),R11   EXTENDED RECORD LENGTH?
       JEQ  WRTSL             YES
       MOVB @FNLROF(R3),R10   CAN WE PUT THE LENGTH IN THIS SECOTR?
       JEQ  NERC3             NO, NEDD THE NEXT
       SETO @DIGFLG
NERC05 MOV  @CHRCNT,R4
       SRL  R10,8
       A    R8,R10
       MOVB R4,*R10+
       AB   @CBH01,@FNLROF(R3)
       JEQ  NERC3              NEED A NEW SECTOR TO GET THE NEXT LENGTH
       JMP  NOCARR
*
WRTSL  SETO @DIGFLG           ONLY ONE DIGIT TO DO
       LI   R0,>E000          ERROR IF RECORD LENGTH TOO LONG IN OLD FORMAT
       C    @CHRCNT,@H00FE
       JH   BADD00            FORGET IT, CAN'T USE OLD FORMAT
       MOVB @FNLROF(R3),R10   DO WE NEED A NEW SECTOR?
       JEQ  NERC3             YES
       SRL  R10,8
       INC  R10               1 FOR CHR COUNT
       A    @CHRCNT,R10
       MOVB R10,R10           DOES IT FIT?
       JEQ  NOCARR            YES
NERC3  BL   @WRTDAT           WRITE THIS SECTOR OUT IF NEC
       JEQ  BADD00
       MOVB @CBH00,@FNLROF(R3)
       BLWP @GETAUU
       MOV  R0,R0
       JNE  BADD00
       INC  @FNLOF2(R3)       NEXT SECTOR
       JNC  NERC00
       AB   @CBH01,@FNLOFM(R3) yalfu
NERC00 BL   @PUTDSL
* NOW TEST IF ALLOCATION HIGHER THAN PREVIOUS
       MOVB @HSALMS(R3),R11
       ANDI R11,>0F00
       CB   R11,@FNLOFM(R3)
       JL   NERC04
       JH   NOCARR
       C    @FNLOF2(R3),@HSALML(R3)          yalfu
       JLE  NOCARR
NERC04 MOVB R11,@HSALMS(R3)
       MOV  @FNLOF2(R3),@HSALML(R3)
NOCARR MOV  @DATMFG,R0        ARE WE WRITING OUT DATA OR RECORD LENGTH
       JNE  NERC10            IT IS DATA
       INV  @DIGFLG
       JNE  NERC05
       MOV  @CHRCNT,R4
       SWPB R4
       MOVB @FNLROF(R3),R10
       SRL  R10,8
       A    R8,R10            POINT TO SECTOR
       MOVB R4,*R10+          PUT IN CHAR CNT
       AB   @CBH01,@FNLROF(R3) UPDATE SECTOR COUNTER
       MOV  R4,R4             ARE WE DONE?
       JEQ  NERC01
       SETO @DATMFG           NOW IN DATA ONLY MODE
       SWPB R4
       MOVB @FNLROF(R3),R10
       JEQ  NERC3

NERC10 MOVB @FNLROF(R3),R10
       SRL  R10,8
       MOV  R10,R2
       A    R8,R10            missing, yalfu
       NEG  R2
       AI   R2,256            # OF BYTE IN THIS SECTOR LEFT
       C    R2,R4
       JL   NERC11
       MOV  R4,R2
NERC11 BL   @IOTOSB
       SWPB R2
       AB   R2,@FNLROF(R3)
       SWPB R2
       SZCB @CBH01,*R3        SAY WE CHANGED THE SECTOR
       S    R2,R4
       JNE  NERC3

NERC01 MOV  @FNLOF2(R3),@FNVNAU(R3)
       MOVB @FNLROF(R3),@FNVROF(R3)
       MOVB @FNLOFM(R3),@FNVSOF(R3)
       MOV  @XRECLN(R9),R0    DO WE WRITE OUT THE >FF BYTE?
       JNE  SYRT02            NO, IT IS X-TENDED
       MOVB @CBHFF,*R10
SYRT02 SZCB @CBH01,*R3        DATA SECTOR CHANGED
       SOCB @CBHF0,@WRTFLG(R3)
SYRT00 B    @FINISH
*
BADDP5 B    @BADOP5
*
BADD00 B    @CLERR
*
FREWRT CB   R6,@CBH02         READ?
       JNE  FW0000            WRITE
       C    @RECNUM,@FNVNAU(R3)
       JHE  BADDP5            TRYING TO READ PAST END OF RECORD
FW0000 C    @RECNUM,@HFFFF    CAN ONLY WRITE >FFFE RECORDS
       JEQ  BADDP5
       MOV  @LRECLN,@DIGFLG   USE DIGFLG FOR # OF BYTES LEFT TO XFER
       MOV  @LRECLN,@CHRCNT
       CLR  R10
       MOV  @XRECLN(R9),R4    IS IT >255?
       JEQ  FSL               NO, SO USUAL RECORD HANDLING
       MPY  @RECNUM,R4        RESULT IN R4,R5
       MOV  R5,@SECIND        SAVE INDEX FOR FUTURE
       SWPB R5                THIS DOES A RIGHT SHIFT LOGICAL 8
       SWPB R4                 FOR R4,R5 PAIR
       MOVB R4,R5
       SZCB R4,R4
       JMP  FXL000

FSL    LI   R11,256
       DIV  @LRECLN,R10       # OF RECORDS PER AU IN R10
       MOV  @RECNUM,R5
       CLR  R4
       DIV  R10,R4
       MPY  @LRECLN,R5
       MOV  R6,@SECIND        SAVE INDEX INTO SECTOR
       MOV  R4,R5
       CLR  R4
FXL000 BLWP @GETAUS           CALCULATE THE SECTOR (ALLOCATE IF NEC)
       MOV  R0,R0
       JNE  BADD00            HARDWARE ERROR OR OUT OF ROOM

       INC  R5                TEST FOR HIGHEST ALLOCATION
*      JEQ  FWR031
       JNE  FWR031            yalfu 1/15/89
       INC  R4
FWR031 MOVB @HSALMS(R3),R11   TEST FOR HIGHEST RECORD ACTUALLY USED
       ANDI R11,>0F00
       SRL  R11,8
       C    R4,R11
       JH   FWR032
       JL   FWR030
       C    R5,@HSALML(R3)
       JLE  FWR030
FWR032 SWPB R4
       SOCB R4,@HSALMS(R3)
       SWPB R4
       MOV  R5,@HSALML(R3)    SET THAT HIGHEST RECORD USED

FWR030 MOV  R8,@RAMBUF
       C    @AUNUM,@FNLOCD(R3) IS THE DESIRED SECTOR THE CURRENT ONE
       JNE  FWR000             NO
       MOVB @FNSEC0(R3),R0
       ANDI R0,>0F00
       CB   R0,@SCINAU+1
       JEQ  FWR001            IS THE SAME
FWR000 MOV  @SCINAU,@SAVSCA   SAVE FOR READING
       MOV  @AUNUM,@SAVAUN
       BL   @WRTDAT           SAVE OUT THE CURRENT RECORD IF IT HAS BEEN CHANGED
       JEQ  BADD00
       MOV  @SAVSCA,@SCINAU   RESTORE THE SECTOR
       MOV  @SAVAUN,@AUNUM
       BL   @PUTDSL
       BLWP @RSECTR           GET IT
       JEQ  BADD00
       MOVB @CBHFF,*R3        SAY IT HAS NOT CHANGED AS YET
FWR001 INC  @RECNUM
       MOV  @SECIND,R10
       CLR  @SECIND           FOR NEXT TIME
       MOV  R10,R2
       A    R8,R10
       NEG  R2
       AI   R2,256
       C    R2,@DIGFLG        USE ALL THE REST OF THE SECTOR?
       JL   FWR036
       MOV  @DIGFLG,R2
FWR036 BL   @IOTOSB           R10 IS SET, R2 IS SET
       S    R2,@DIGFLG
       JNE  FXL000
       MOVB @CBH00,@FNLROF(R3)  ZERO OUT TO PREVENT FUTURE PROBLEMS
WRT2   C    @RECNUM,@FNVNAU(R3) UPDATE HIGHEST RECORD WRITTEN
       JL   WRT2A
       MOV  @RECNUM,@FNVNAU(R3)
WRT2A  CB   @CBH03,@OPCODE
       JEQ  SYRT03            TELL THEM THE SECTOR AND FILE HAS CHANGED
       B    @FINISH           ALL DONE
*
SYRT03 B    @SYRT02
*
IOTOSB
FWR012 MOVB @CPUFLG,@PASVDP
       MOV  R2,@PASCNT
       MOV  @MYUADL,@PASADL
       MOVB @MYUADH+1,@PASADH
       MOV  R10,@PASDSR
*
       BLWP @PASDAT
       MOV  R2,R6
       BLWP @ADDADR
       A    R6,R10            UPDATE POINTER
       RT
*
WRTD01 MOV  @FNLOCD(R3),@AUNUM
       JNE  WRTD03
*
WRTDAT
* WRITE OUT THE DATA BUFFER AS DESCRIBED BY THE DATA BLOCK
* IF DATA BUFFER POINTS TO 0 THEN DON'T WRITE IT
       CLR  R0           NO ERROR SO FAR
       CB   *R3,@CBHFE   WAS SECTOR ALTERED?
       JNE  WRTD00       NO
       SOCB @CBH01,*R3   SAY IT WAS NOT ALTERED
       MOV  R8,@RAMBUF
       MOVB @FNSEC0(R3),R0
       ANDI R0,>0F00
       SWPB R0
       MOV  R0,@SCINAU
       JEQ  WRTD01
       MOV  @FNLOCD(R3),@AUNUM
WRTD03 BLWP @WSECTR
WRTD00 RT                SETS = FLAG IF ERROR
*
DATNUM MOV  *R10,R0
       ANDI R0,>001F
       SLA  R0,1
       BLWP @CIF
       MOV  *R10,R0
       ANDI R0,>07E0
       SRL  R0,5
       BLWP @CIF
       MOV  *R10+,R0
       SRL  R0,11
       BLWP @CIF
*      DECT R10
       MOV  *R10,R0
       ANDI R0,>001F
       BLWP @CIF
       MOV  *R10,R0
       ANDI R0,>01E0
       SRL  R0,5
       BLWP @CIF
       MOV  *R10,R0
       SRL  R0,9
       AI   R0,1900
       CI   R0,1980
       JHE  DATNU1
       AI   R0,100
DATNU1 BLWP @CIF
       RT
