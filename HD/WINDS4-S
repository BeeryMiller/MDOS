*
       CB   R2,R4           TEST MSB
       JH   BAD211            FILE TOO LARGE FOR MEMORY
       JL   L4C               SMALL ENOUGH TO FIT
       C    R6,R5           MSB'S EQUAL SO TEST LSW
       JH   BAD211
* TEST IF LENGTH IS ZERO AND IF SO, THEN DONE
L4C    SRL  R11,8
       CLR  R5                STARTING SECTOR IS ALWAYS 0
       CLR  R4
L4E    MOV  R2,R2             TEST FULL SECTORS LEFT
       JNE  L4B               YES, IT IS NON ZERO
       MOV  R11,R11           TEST OFFSET FOR 0
       JEQ  LOADED            ALL DONE
* NOW LOAD PROGRAM, WE KNOW THE FOLLOWING
*      R2 CONTAINS THE NUMBER OF FULL SECTORS
*      R11 MSB CONTAINS THE NUMBER OF BYTES IN ANY LAST SECTOR
*               IF NON 0
L4B    MOV  R8,R7             START OF SECTOR
       BLWP @GETAUS
       MOV  R0,R0             DEVICE ERROR
       JNE  BAD211
       MOV  R8,@RAMBUF
       BLWP @RSECTR           GET DATA SECTOR
       JEQ  BAD211            READ SECTOR ERROR
* NOW CALCULATE THE NUMBER OF BYTES TO USE OF THIS SECTOR
       LI   R6,256
       MOV  R2,R2             IS THIS THE LAST SECTOR?
       JNE  L4A               YES, SO IT IS A PARTIAL
       MOV  R11,R6            LAST SECTOR
       CLR  R11
       INC  R2                JUST TO MAKE IT EQUAL
L4A    DEC  R2
* NOW LOAD BYTE BY BYTE IN MEMORY
       MOVB @CPUFLG,@PASVDP   VDP/CPU
       CLR  @PASRW            DSR TO USER
       MOV  @MYUADL,@PASADL   USER ADDRESS
       MOVB @MYUADH+1,@PASADH
       MOV  R6,@PASCNT       NUMBER OF BYTES
       MOV  R8,@PASDSR        WHERE IT IS IN CPU RAM
       BLWP @PASDAT
       BLWP @ADDADR
* TO BE HERE SECTOR COMPLETE SO GET NEXT SECTOR OF DATA
L6     INC  R5                TEST IF THIS CONTIGUOUS SECTORS COMPLETE
       JMP  L4E
       PAGE
NTSAVE
* TO BE HERE WE HAVE AN OPEN OUTPUT OR UPDATE TO A NONEXIST FILE
* WE KNOW IN THE FILE NAME BLOCK, THERE IS
* 1 A PTR TO THE FCB                         2 DATA BUFFER NOT IN RAM=0
* 3 LOGICAL OFFSET LEVEL  2=0                4 PHYSICAL LOC OF FCB ON DISK
* 5 PHYSICAL LOC OF DATA BUF ON DISK=0       6 OFFSET =0, DRIVE # LOADED
* 7 PATHANME IS LOADED 40 CHAR
*
* WE KNOW IN THE FCB BLOCK
* 1 FILE NAME (10 CHAR)                      2 CHARACTERS "FI"
* ALL OTHER BYTES ARE ZERO
* NOW GET FLAGS TO STORE IN FILE FCB
       BL   @PBFST
*
* NOW LOAD TIME OF CREATION AND LAST UPDATE (NOW ONE AND THE SAME)
*
FNLR   SOCB @CBH10,R5         file has changed since last archive
       MOVB R5,@FSTATF(R9)    STORE FLAGS IN FCB
*
* NOW TEST LOGICAL RECORD LENGTH
*
RLEN1  MOV  @LRECLN,R5           TEST AND STORE LOG REC LENGTH
       JNE  RLEN2             BRANCH IF NOT ZERO
       LI   R5,80             SET DEFAULT TO 80 IN PAB
*
* FILE NAME BUFFER HAS PHYSICAL LOCATION OF FCB ON DISK
* NOW GET INITIAL ALLOCATION
*
RLEN2  MOV  R5,@LRECLN        yalfu
       MOVB R5,R5             IS IT GREATER THAN 255?
       JNE  RLEN5             YES, SO USE EXTENDED RECORD LENGTH
       COC  @H0010,R6         IS IT VARIABLE LENGTH
       JNE  RLEN2A            NO
       CI   R5,255            IS IT 255?
       JHE  RLEN5             YES, SO USE EXTENDED LENGTH
RLEN2A SWPB R5
       MOVB R5,@RECLEN(R9)    STORE RECORD LENGTH
       SWPB R5
       COC  @H0010,R6         FIXED?
       JNE  RLEN2C            IT IS FIXED
       INC  R5
RLEN2C CLR  R10               GET NUMBER OF REC PER AU
       LI   R11,256
       DIV  R5,R10            R10 HAS # OF REC/AU
       SWPB R10
       MOVB R10,@RECPAU(R9)
       SWPB R10
       MOV  @RECNUM,R5
       JEQ  RLEN3
       CLR  R4
       DIV  R10,R4
       MOV  R5,R5             IS THERE A REMAINDER?
       JNE  RLEN2B            YES
       DEC  R4                ELSE MAKE BASE 0 FOR # OF SECTORS
RLEN2B MOV  R4,R5
       CLR  R4
RLEN5B BLWP @GETAUS           GET PHYSICAL AU'S
       MOV  R0,R0             ERROR?
       JNE  BAD012            ERROR, I/O OR OVERFLOW ERROR
RLEN3  BL   @WRTFCB           WRITE FCB FOR FUTURE REF
       JEQ  BAD012            ERROR IN I/O
RLENPC CLR  @RECNUM           ZERO OUT #OF RECORDS FOR FUTURE
       B    @FINISH
*
RLEN5  MOVB @CBH00,@RECLEN(R9)  IT IS A EXTENDED RECORD LENGTH TYPE FILE
       MOV  R5,@XRECLN(R9)
*  NOW FOR INITIAL ALLOCATION PROBLEM
*   NEED TO ADD 2 TO VARIABLE RECORD FILES
       COC  @H0010,R6         TEST IF VARIABLE
       JNE  RLEN5A            IT IS FIXED
       LI   R0,>4000
       INCT R5
       JOC  BAD012            RECORD LENGTH TOO LARGE
RLEN5A MOV  @RECNUM,R11
       JEQ  RLEN3             NO INITIAL ALLOCATION
       MOV  R5,R4
       MPY  R11,R4            # OF BYTES IN R4,R5
       SWPB R5                GET SECTORS, NOT BYTES
       MOVB R5,R11            SAVE ROUND OFF
       SWPB R4
       MOVB R4,R5
       SZCB R4,R4
       MOVB R11,R11           IS THERE A REMAINDER?
       JNE  RLEN5B            YES, SO CORRECT
       DEC  R5
       JNC  RLEN5B
       DEC  R4
       JMP  RLEN5B
       PAGE
NLOAD
* TO BE HERE MUST BE OPEN
* IF OPEN OUTPUT THEN USE THE NEW PARAMETERS AND ZERO RECORD LENGTHS
* TEST FOR OUTPUT BUT FIRST GET FLAGS
       BL   @PBFST            GET FILE STATUS FLAGS FROM PAB
       SETO *R3             RESERVE FILE BLOCKS
       MOVB @DRIVID,@1(R3)
* R6 HAS RAW OPEN STATUS FLAGS
       COC  @H0002,R6
       JNE  RLENV
       CZC  @H0004,R6
       JNE  RLENV
* TO BE HERE THEN OPEN OUTPUT SO GO TO DELETE IT FIRST IF FLOPPY
       CLR  @FSTATF(R9)       ZERO FLAGS AND REC/AU
       CLR  @EOFOST(R9)       ZERO EOF AND REC LEN
       CLR  @LEV3RC(R9)       ZERO HIGHEST FIXED WRITTEN OR VAR USED
       SZCB @CBH0F,@NIBLES(R9)
       JMP  NTSAVE       GO TO GET FLAGS AND REC LENNGTH
*
*  TO BE HERE, MUST BE OPEN NOT OUTPUT SO SEE IF FILE PARMS MATCH
*  SIBLIN POINTS TO FILE BUFFER
*
RLENV  MOVB @FSTATF(R9),R7    GET FILE STATUS FLAGS
       LI   R0,>4000          ERROR CODE TRYING TO OPEN PROG FILE FOR READ
       ANDI R7,>8300          TEST IF PROGRAM FILE
*  NOW TEST IF FILE TYPES COMPATIBLE
* R5 HAS PAB STATUS IN FCB FORM R5 HAS STATUS IN PAB FORM
       CB   R5,R7             TEST IF COMPATIBLE
       JEQ  COMPTB
BAD012 B    @BADOPC           CLEAR OUT THE PAB IN USE AND ERROR OUT
*
*  NOW IF FLAGS ARE COMPATIBLE,TEST RECORD LENGTH
COMPTB MOVB @RECLEN(R9),R7    GET RECORD LENGTH OF FILE
       SRL  R7,8
       JNE  COMPTC            THIS IS THE RECORD LENGTH
       MOV  @XRECLN(R9),R7    USE EXTENDED
COMPTC MOV  @LRECLN,R11       TEST IF PAB REC LENGTH IS ZERO
       JNE  TRLN              BRANCH IF NOT ZERO
       MOV  R7,@LRECLN        IF ZERO PUT IN CORRECT LENGTH
TRLN   C    R7,@LRECLN        TEST IF LENGTHS ARE EQUAL
       JNE  BAD012            ERROR RECORD LENGTHS UNEQUAL
*
* set EOF offset parameters...
*
       MOV  @LEV3RC(R9),R0    GET MID AND LSB IF VARIABLE USED
       SWPB R0                    HIGHEST RECORD IF FIXED USED
       MOV  R0,@FNVNAU(R3)
*
       MOVB @EOFOST(R9),@FNVROF(R3)
       CLR  R4
       MOVB @NIBLES(R9),R4
       ANDI R4,EFOSMS
       MOVB R4,@FNVSOF(R3)
*
       CZC  @H0002,R6         test for open input
       JNE  OAP010            not input --- either output or append
       COC  @H0004,R6         test if open input
       JEQ  RLENPC
*
OAP010 COC  @H0010,R6         test fixed/variable records
*
* MODSET to correct problem with relative file access    Clint Pulley 92/11/22
* If opening in update mode, get sector and date/time data
*
       JEQ  OAP003            IF VARIABLE
*
* FIXED, MUST BE UPDATE MODE SO COPY REQUIRED DATA TO FCB
*
       MOV  @LEV2RC(R9),@HSALML(R3)
       MOVB @NIBLES(R9),R4
       SRL  R4,4
       MOVB R4,@HSALMS(R3)
       MOV  @DATLUF(R9),@LSTUP2(R3)
       MOV  @DATLUF+2(R9),@LSTUP1(R3)
       JMP  OAP002
*
* End of MODSET
*
* NOW TEST APPEND MODE
OAP003 COC  @H0006,R6         TEST IF APPEND MODE
       JNE  OAP002            NO
*
       MOV  @FNVNAU(R3),R5    IT IS APPEND SO MOVE # USED TO POINTER
       MOV  R5,@FNLOF2(R3)    GET MID AND LSB
       MOVB @EOFOST(R9),@FNLROF(R3) GET BYTE POINTER IN SECTOR
       MOVB R4,@FNLOFM(R3)    GET THE MSB OF THE SECTOR
       SRL  R4,8
       JNE  OAP000
       MOV  R5,R5
       JEQ  OAP002
OAP000 DEC  R5
       JOC  OAP001
       DEC  R4
OAP001 BLWP @GETAUS
       MOV  R0,R0
       JNE  BAD012
       MOV  R8,@RAMBUF
       BLWP @RSECTR           GET THE SECTOR TO APPEND TO
       JEQ  BAD012
       BL   @PUTDSL
OAP002 B    @RLEN1
       PAGE
*    DELETE FILE COMMAND
*
*
*
DELETE CI   R2,WBUFEN
       JNE  ISOPEN            BRANCH IF OPEN
       B    @ISNOPN
*
* TO BE HERE, TRYING TO DELETE A FILE ALREADY OPEN
* THEREFORE, GET TO TOP FCB
* R2 POINTS TO FILE NAME POINTER BLOCK
* GET FCB DATA BUFFER POINTER TO R3
*
ISOPEN
*
* TEST IF PROTECTED
*
TSTPRO MOVB @FSTATF(R9),R1
       COC  @H0800,R1
       JNE  DELOOP            BRANCH IF TRYING TO DELETE PROTECTED FILE
DELEMD B    @BADOP1
*
* NOW START DELETING AT THE TOP FCB
DELOOP BL   @TOPFCB
       JEQ  BAD012
*
       C    @AUNUM,@EMDKCB+2  yalfu
       JEQ  DELEMD            can't delete an active emulate file...
*
* TO BE HERE, AT THE TOP MOST FCB SO START DELETING
*
ATTOP  MOV  @FNLOCF(R3),@STRTSR  SAVE PTR TO FIRST FCB ON DISK
ATTOP1
* THIS ROUTINE DELETES OR FREES ALL SECTORS IN THE VIB
       MOV  R9,R6             GET PTR IN R6
       AI   R6,SEPTRS         TO DATA POINTERS
       MOV  R9,R5
       AI   R5,256            R5 IS ENDING CRITERION
       MOV  @AUTSFD(R9),R11   ANY TO RELEASE?
       JEQ  FRESE1            NO
* NOW USE TEST FOR END OF PTRS
FRESE2 C    R6,R5
       JEQ  FRESE1            HAVE GONE TROUGH SECTOR
       MOV  *R6+,R1
       JEQ  FRESE1            A NON EXISTANT POINTER
       MOV  *R6+,R2           OTHERWISE CONTINUE
       S    R1,R2             NOW R9 CONTAINS THE NUMBER TO DELETE
       INC  R2
       S    R2,R11
       JOC  FRESE3
       A    R2,R11
       JEQ  FRESE1
       MOV  R11,R2
* NOW GET DISK MAP FROM TRACK 0
FRESE3 DEC  R2
       BLWP @FRBITM           ZERO OUT BITS
       MOV  R0,R0             CHECK FOR ERROR
       JEQ  FRESE2            NO ERROR
FRSER0 B    @BADOPC           CLEAR OUT THE PAB IN USE AND ERROR
*
* NOW FREE UP THIS SECTOR ITSELF
* R3 POINTS TO FILE NAME BUFFER SO GET SECTOR THERE
*
FRESE1 MOV  @FNLOCF(R3),R1
       CLR  R2
       BLWP @FRBITM
       MOV  R0,R0
       JNE  FRSER0
* NOW GET NEXT IN STRING
* SIBLIN POINTS TO FCB SO SEE IF A NEXT FCB IN CHAIN
       MOV  @PTRNXT(R9),@FNLOCF(R3)
       JEQ  DELNAM            JUMP IF COMPLETE
* OTHERWISE BRING IN NEXT FCB
       MOV  @NIBLES(R9),R1    GET AU NUMBER
       ANDI R1,>000F
H000F  EQU  $-2
       MOV  R1,@SCINAU        FIRST SECTOR
       MOV  R9,@RAMBUF
       MOV  @FNLOCF(R3),@AUNUM
*      SRL  R1,12
*      MOVB R1,@FNSEC0(R3)
       BLWP @RSECTR
       JEQ  FRSER0            READ ERROR
       JMP  ATTOP1            CONTINUE UNTIL ALL SECTORS FREED
*
* TO BE HERE, IT COULD BE DELETE, OR SAVE, OR WRITE DIRECT, OR OPEN OUTPUT
*
DELNAM SZCB @FNSEC0(R9),@FNSEC0(R9)  ZERO OUT POINTERS TO SIBLINS
       MOV  @OPCODE,R6    GET OPCODE
       CB   R6,@CBH07           TEST IF DELETE
       JEQ  DELNA1            BRANCH IF DELETE
* OTHERWISE GET TOP FCB BACK FROM BIT MAP
       MOV  @STRTSR,R0
       MOV  @PARFPT(R9),@STRTSR SAVE PTR TO DIR OF FILE PTRS
       MOV  R8,R1              BUFFER USED BY GETSEC
COT001 LI   R5,1
       BLWP @GETSEC
       MOV  R0,R0             ERROR IN DEVICE?
       JNE  FRSER0
* NOW JUST CONTINUE
COT000 B    @CONTIN
*
* NOW MUST DELETE THE NAME FROM THE DIRECTORY AND FREE THE TWO OR THREE DATA
* BUFFERS USED.
* PTR TO DIRECTORY IS IN THE FILE BLOCK DESCRIPTOR. R3 POINTS TO FCB
* TO FCB
*
DELNA1 MOV  @INDPTR(R3),@AUNUM  GET POINTER
       MOV  R8,@RAMBUF        GET BUFFER
       CLR  @SCINAU           FIRST SECTOR IN AU
       BLWP @RSECTR           GET PTR TO FILES
       JEQ  FRSER0
*
* NOW GET THE PTR FROM NOPTRS WHERE IT IS IN STACK, DELETE IT AND MOVE UP THE
* REST.
*
       MOV  @STRTSR,R5        R5 HAS VALUE TO LOOK FOR
       MOV  R8,R7             R7 PTS TO TOP
       CLR  R6                R6 IS COUNTER
DEL1   C    *R7+,R5
       JEQ  MAT               BRANCH IF A MATCH
       INCT R6                OTHERWISE INCR6
       JMP  DEL1
*
MAT    CI   R6,252            NOW TEST IF COMPLETE
       JEQ  DEL2
HFFFE  EQU  $+2
CBHFE  EQU  $+3
       MOV  *R7,@-2(R7)
       INCT R7
       INCT R6
       JMP  MAT
*
DEL2   CLR  @-2(R7)
* NOW SUBTRACT 1 FROM NUMBER OF FILE PTRS BUT FIRST WRITE THIS
       BLWP @WSECTR
       JEQ  FRSER0            ERROR?
DEL3   MOV  @254(R8),@AUNUM
       BLWP @RSECTR
       JEQ  FRSER0
* NOW TO SUBTRACT
       AB   @CBHFF,@NUMFIL(R8)
* WRITE IT BACK
       BLWP @WSECTR
       JMP  FRSER0            WILL REPORT ERROR IF NECESSARY
*
FRESEC DATA WRKREG,FRESEF
*
FRESEF MOV  @2(R13),R1
       MOV  R1,R0
       SRL  R1,3
       AI   R1,FDKVIB+BITMAP
       LI   R10,>0100
       MOVB R10,@VIBCHG
       ANDI R0,>0007
       JEQ  ZNBYTE
       SLA  R10,0
ZNBYTE MOVB *R1,R8
       SZCB R10,R8
       MOVB R8,*R1
       RTWP
*
PBFST  CLR  R5
       COC  @H0010,R6
